## 1.2 JavaScript, ESNext & TypeScript Fundamentals in React Native : Async Patterns

# Async Patterns in React Native TypeScript

Modern React Native apps rely on asynchronous operations for network requests, file I O, timers and more. Understanding Promises and async–await helps write clear non blocking code and handle errors gracefully.

**What Are Promises**  
A Promise represents a value that may be available now later or never. Promises have then and catch methods to handle success and failure.

**Async–Await Syntax**  
Async–await builds on Promises to write asynchronous code in a synchronous style. An async function returns a Promise and the await keyword pauses execution until the Promise resolves or rejects.

**Error Propagation**  
Errors in async code bubble up like synchronous code. Use try–catch inside async functions or attach catch handlers to Promises to handle failures.

**Example 1 Fetching Data**  
Fetch a list of items from an API and handle errors

&&&javascript  
import React useEffect useState from react-native  

function ItemList() {  
  const [items setItems] = useState([])  
  const [error setError] = useState()  

  async function loadItems() {  
    try {  
      const response = await fetch(http colon slash slash example dot com slash items)  
      if (!response.ok) throw new Error(response statusText)  
      const data = await response json()  
      setItems(data)  
    } catch (err) {  
      setError(err message)  
    }  
  }  

  useEffect(() => {  
    loadItems()  
  }, [])  

  if (error) {  
    return (<Text>Error colon {error}</Text>)  
  }  

  return items map(item => (<Text key={item id}>{item name}</Text>))  
}  
&&&

**Example 2 Parallel Requests**  
Run multiple requests in parallel and wait for all  

&&&javascript  
async function fetchAll() {  
  try {  
    const [a b] = await Promise all([  
      fetch(api slash a) then(res => res json()),  
      fetch(api slash b) then(res => res json())  
    ])  
    console log(a b)  
  } catch (err) {  
    console warn(Error fetching parallel)  
  }  
}  
&&&

**Benefits**  
- Readable flow matching synchronous code  
- Centralized error handling with try–catch  
- Easy composition with Promise methods  

**Negatives**  
- Forgetting await leads to unresolved Promises  
- Uncaught rejections if errors not handled  
- Blocking UI thread if heavy computation inside async  

**When to Use**  
- Network calls using fetch or axios  
- Reading local files or databases  
- Timers and animations  
- Any I O in React Native  

Mastering async patterns ensures responsive performant React Native apps with robust error handling and clean code structure  