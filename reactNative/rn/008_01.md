# React Native Interview Questions: Event Loop, Concurrency, Microtasks vs Macrotasks, and JS Thread Blocking

These interview questions evaluate a candidate‚Äôs understanding of JavaScript‚Äôs concurrency model, how the **event loop** works, and how **React Native's JS thread** interacts with UI rendering. They also cover distinctions between **microtasks** and **macrotasks**, and how to avoid **blocking the UI thread**.

---

## üîÅ Event Loop Basics

### 1. What is the event loop in JavaScript and why is it important in React Native?

**Expected Answer**: The event loop manages the execution of asynchronous code in JavaScript. In React Native, it helps coordinate the execution of tasks between the JS thread and the UI thread, ensuring smooth rendering and user interaction.

---

### 2. How many threads does React Native use and what are their responsibilities?

**Expected Answer**:

| Thread        | Responsibility                                |
|---------------|-----------------------------------------------|
| JS Thread     | Runs JavaScript code (logic, rendering, etc.) |
| UI Thread     | Manages layout, animations, rendering          |
| Native Modules| Handles background tasks (networking, storage) |

---

## ‚è± Microtasks vs Macrotasks

### 3. What is the difference between a microtask and a macrotask?

**Expected Answer**:  
- Microtasks (e.g., `Promise.then`, `queueMicrotask`) are executed immediately after the current execution stack and before any macrotask.  
- Macrotasks (e.g., `setTimeout`, `setImmediate`) are deferred to the next tick of the event loop after microtasks have cleared.

---

### 4. Predict the output of the following code:

```js
console.log('A');

setTimeout(() => {
  console.log('B');
}, 0);

Promise.resolve().then(() => {
  console.log('C');
});

console.log('D');
```

**Expected Answer**:
A  
D  
C  
B

---

## üõë Blocking the JS Thread

### 5. What happens if you block the JS thread in React Native?

**Expected Answer**: The UI becomes unresponsive. Animations, navigation, gestures, and re-renders will not work until the blocking code finishes.

---

### 6. Identify the issue in this code and explain its impact:

```js
const heavyTask = () : void => {
  const start = Date.now();
  while (Date.now() - start < 3000) {
    // Busy-wait loop
  }
  console.log('Done');
};
```

**Expected Answer**: This synchronous loop blocks the JS thread for 3 seconds, freezing the UI and preventing any user interaction.

---

### 7. How can you refactor the code above to avoid blocking the UI thread?

**Expected Answer**:

```js
const runInChunks = (items: number[]) : void => {
  const chunkSize = 100;

  const process = (start: number) : void => {
    const end = Math.min(start + chunkSize, items.length);
    for (let i = start; i < end; i++) {
      // Process item
    }

    if (end < items.length) {
      setTimeout(() => process(end), 0);
    }
  };

  process(0);
};
```

---

## üîç Advanced Concurrency

### 8. When would you use `Promise.all` vs `Promise.allSettled` in a React Native app?

**Expected Answer**:  
- `Promise.all` is used when all promises must succeed, and it rejects as soon as one fails.  
- `Promise.allSettled` waits for all promises to finish and returns both resolved and rejected results, useful when you don‚Äôt want one failure to stop the rest.

---

### 9. Why should long-running calculations not be run directly on the JS thread in React Native?

**Expected Answer**: Because it will block the event loop, preventing UI updates and degrading user experience. Heavy tasks should be split into smaller chunks or offloaded to native modules or worker threads.

---

### 10. How can you debug JS thread blocking in a React Native application?

**Expected Answer**:
- Use Flipper‚Äôs performance tools to inspect JS frame durations  
- Monitor slow UI interactions or delayed gesture responses  
- Use the Hermes profiler or Chrome DevTools for long task detection

---

## ‚úÖ Bonus

### 11. What's the preferred way to handle an expensive task without freezing the UI?

**Expected Answer**: Use background threads (e.g., `react-native-threads`), break tasks into asynchronous chunks with `setTimeout`, or offload to native modules.

---

## Conclusion

A solid understanding of the **event loop**, **microtask vs macrotask prioritization**, and **JS thread behavior** is vital for building responsive React Native applications. These questions help ensure candidates can write non-blocking, performant code and handle concurrency like a pro.