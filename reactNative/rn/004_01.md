

âœ… JavaScript & ESNext -- Fundamentals
------------------------------------

### ðŸ”¹ Closures

### 1\. **What is a closure in JavaScript? Give a real-world example.**

**Answer:** A closure is when an inner function retains access to variables from its outer function even after the outer function has returned.

Example:\
```\
function createCounter() {\
let count = 0;\
return function() {\
count++;\
return count;\
};\
}

const counter = createCounter();\
counter(); // 1\
counter(); // 2\
```\
The `counter` function retains access to `count` even though `createCounter` has finished execution.

* * * * *

### 2\. **How do closures help in maintaining state in functional components or hooks in React Native?**

**Answer:** React hooks like `useState` and `useEffect` rely on closures. The component's internal functions "close over" the current state, preserving it across renders and function calls.

* * * * *

### 3\. **What are some memory-related drawbacks of closures, and how do you avoid them?**

**Answer:** Closures can cause memory leaks if they retain references to large objects or DOM elements. Use proper cleanup in `useEffect` and avoid creating unnecessary closures inside render methods.

* * * * *

### ðŸ”¹ Hoisting

### 4\. **What is hoisting in JavaScript? Which declarations are hoisted and how does it affect execution order?**

**Answer:** Hoisting is the JavaScript behavior where variable and function declarations are moved to the top of their scope. Only **declarations** are hoisted, not **initializations**.

Example:\
```\
console.log(a); // undefined\
var a = 5;\
```\
`var a` is hoisted, but not `a = 5`.

* * * * *

### 5\. **How do `let`, `const`, and `var` differ in terms of hoisting behavior?**

**Answer:**

-   `var` is hoisted and initialized with `undefined`.

-   `let` and `const` are hoisted but stay in the **Temporal Dead Zone** (TDZ) until declared, so accessing them before declaration throws an error.

* * * * *

### ðŸ”¹ `this`

### 6\. **Explain how the value of `this` changes depending on context in JavaScript.**

**Answer:** `this` refers to the **calling context**:

-   In global scope: `this` is `window` (in browsers).

-   In object methods: `this` refers to the object.

-   In class methods: `this` refers to the class instance.

-   In functions: `this` is `undefined` in strict mode or `window` otherwise.

* * * * *

### 7\. **How does `this` behave differently in arrow functions compared to traditional functions?**

**Answer:** Arrow functions **don't have their own `this`**. They inherit `this` from the enclosing context, which is helpful to avoid binding when accessing `this` in methods or callbacks.

* * * * *

### 8\. **In a class-based component, how do you bind event handlers to preserve `this` context?**

**Answer:** You either:

1.  Bind in the constructor:\
    `this.handleClick = this.handleClick.bind(this);`

2.  Use arrow functions:\
    `handleClick = () => { ... };` (auto binds `this`)

* * * * *

### ðŸ”¹ Arrow Functions

### 9\. **What are arrow functions, and how do they differ from normal functions in terms of syntax and behavior?**

**Answer:**

-   Shorter syntax: `const sum = (a, b) => a + b;`

-   No `this`, `arguments`, `super`, or `new.target` bindings.

-   Cannot be used as constructors.

* * * * *

### 10\. **Why don't arrow functions have their own `this` binding? How is that useful in React or React Native development?**

**Answer:** Arrow functions inherit `this` from their enclosing scope, which helps avoid context errors in callbacks or event handlers. In React, they are commonly used to avoid binding `this` manually in class components or closures.

* * * * *
