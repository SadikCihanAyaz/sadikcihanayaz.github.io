# React Native TypeScript Interview Questions: Interfaces vs Types, Generics, Type Narrowing, Module Augmentation

TypeScript enhances JavaScript with strong typing, which improves readability, refactoring, and reliability‚Äîespecially in large React Native projects. The following interview questions test core TypeScript concepts including **interfaces**, **type aliases**, **generics**, **type narrowing**, and **module augmentation**.

---

## üìê Interfaces vs Type Aliases

### 1. What is the difference between `interface` and `type` in TypeScript?

**Expected Answer**:
- `interface` is primarily used for defining object shapes and is extendable via `extends`.
- `type` is more flexible and can represent unions, primitives, tuples, etc.
- Both can define objects, but `interface` is generally preferred for public APIs.

---

### 2. Rewrite this `type` as an `interface`:

```js
type User = {
  id: number;
  name: string;
};
```

**Expected Answer**:

```js
interface User {
  id: number;
  name: string;
}
```

---

### 3. Can interfaces and types be merged or extended differently?

**Expected Answer**:
- `interface` can be **merged** across declarations.
- `type` cannot be merged but can be **intersected** (combined using `&`).

---

## üß¨ Generics

### 4. What are generics and why are they useful in TypeScript?

**Expected Answer**:
Generics allow you to create reusable, type-safe components and functions without specifying exact types upfront.

---

### 5. Convert the following to use generics:

```js
function identity(value: string): string {
  return value;
}
```

**Expected Answer**:

```js
function identity<T>(value: T): T {
  return value;
}
```

---

### 6. How would you create a generic React Native hook that works with any type of value?

**Expected Answer**:

```js
function useGenericState<T>(initial: T): [T, (val: T) => void] {
  const [value, setValue] = useState<T>(initial);
  return [value, setValue];
}
```

---

## üîç Type Narrowing

### 7. What is type narrowing and when is it used?

**Expected Answer**:
Type narrowing is the process of refining a union or broader type to a more specific one based on conditions or control flow (e.g., `typeof`, `in`, `instanceof`).

---

### 8. What will this function return and how is type narrowing applied?

```js
function format(value: string | number): string {
  if (typeof value === 'string') {
    return value.toUpperCase();
  }
  return value.toFixed(2);
}
```

**Expected Answer**:
- If value is a string ‚Üí returns the uppercased string.
- If value is a number ‚Üí returns the number with two decimals.
- `typeof` is used to narrow the type.

---

## üß± Module Augmentation

### 9. What is module augmentation in TypeScript?

**Expected Answer**:
Module augmentation allows you to extend or modify existing type definitions (e.g., extending third-party libraries or global types).

---

### 10. How would you add a custom method to the global `String` object?

**Expected Answer**:

```js
declare global {
  interface String {
    toSlug(): string;
  }
}

String.prototype.toSlug = function () {
  return this.toLowerCase().replace(/\s+/g, '-');
};
```

---

## ‚úÖ Bonus

### 11. When should you prefer `Record<string, T>` over `{ [key: string]: T }`?

**Expected Answer**:
Use `Record<string, T>` when you want a more concise, built-in utility to express an object with known key/value types. Both are functionally equivalent, but `Record` is more semantic.

---

### 12. What does `keyof` do in a generic utility type?

**Expected Answer**:
It creates a union of the keys of a given type.

```js
type User = { id: number; name: string };
type UserKeys = keyof User; // 'id' | 'name'
```

---

## Conclusion

These questions cover fundamental TypeScript knowledge for React Native developers. A solid grasp of interfaces, generics, type guards, and advanced utilities like module augmentation is crucial for writing scalable and safe TypeScript code.