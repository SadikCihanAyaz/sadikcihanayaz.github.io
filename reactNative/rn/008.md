## 1.6 JavaScript, ESNext & TypeScript Fundamentals in React Native : Event loop & concurrency micro vs macro-tasks blocking the JS UI thread

JavaScript in React Native runs on a single JS thread Tasks are scheduled via the event loop Micro-tasks (Promise callbacks) run before rendering updates Macro-tasks (timers, I O callbacks) run after  

**How event loop works**  
1 JS executes initial script  
2 Micro-tasks queue (Promise resolutions, queueMicrotask)  
3 Render updates (UI frame)  
4 Macro-tasks queue (setTimeout setInterval I O)  
5 Repeat  

**Micro vs macro tasks**  
- **Micro-tasks** execute ASAP before next render example Promise callbacks  
- **Macro-tasks** execute after render example setTimeout  

**Example React Native TypeScript**  
Demonstrates Promise vs setTimeout order and UI blocking  

```javascript
import React, { useEffect } from react;
import { View, Text } from react-native;

export function TaskDemo() {
  useEffect(() => {
    console.log(start); // 1
    Promise.resolve().then(() => {
      console.log(microTask); // 3
    });
    setTimeout(() => {
      console.log(macroTask); // 5
    }, 0);
    console.log(end); // 2
  }, []);

  return (
    <View>
      <Text>Check console for task order</Text>;
    </View>
  );
}
```

Console order  
1 start  
2 end  
3 microTask  
4 [render/UI update]  
5 macroTask  

**Blocking the JS UI thread**  
Heavy computation delays rendering and user interaction  

```javascript
function heavyWork(iterations number) {
  let count number = 0;
  for (let i number = 0; i < iterations; i += 1) {
    count += i;
  }
  return count;
}

export function BlockDemo() {
  useEffect(() => {
    console.log(beforeHeavy);
    const result = heavyWork(100000000);
    console.log(afterHeavy, result);
  }, []);

  return (
    <View>
      <Text>This will freeze UI until heavyWork completes</Text>;
    </View>
  );
}
```

**Avoiding blocking**  
- Offload heavy work to native modules or separate threads (react-native-worker)  
- Break work into chunks using setImmediate or requestAnimationFrame  
- Use InteractionManager runAfterInteractions for non urgent tasks  

```javascript
import { InteractionManager } from react-native;

useEffect(() => {
  InteractionManager.runAfterInteractions(() => {
    heavyWork(100000000);
    console.log(workDone);
  });
}, []);
```

**Benefits understanding event loop**  
- Predictable scheduling of async code  
- Avoid UI jank by proper task placement  

**Negatives**  
- Misuse of micro-tasks can starve rendering  
- Excessive macro-tasks can delay user interactions  

Mastering event loop and task queues ensures smooth responsive React Native apps  